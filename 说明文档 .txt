1.Evaluate
适应性评估相关函数

#将层-GPU编码还原为初始编码
#输入：n*k维的GPU分布矩阵（染色体矩阵部分）
#输出：j*k维的层-GPU矩阵，每行代表对应的Transformer层可以由哪些GPU训练
map_numbers_to_rows(input_matrix, n, k, j)

# 统计每一层可处理GPU数量
count_nonzero_per_row(input_matrix)

# 获取 GPU_task 矩阵（任务的每个层在哪个GPU上计算）
trans_GPU_task(input_matrix1, input_matrix21, input_matrix22, gpu_num, i, j)

# 定义获取GPU的取余函数
GPU_mod(gpu, gpu_num)

2.Genetic
遗传算法相关函数

#子代任务顺序交叉函数
#通过交叉映射生成新的子代染色体
generate_new_chromosome(chromosome1,chromosome2)

#交叉中间函数（交叉映射函数）
chromosome_mapping(sorted_array1_2d, sorted_array2_2d)

#交叉中间函数（随机选择一个交叉点，将两条染色体分为四部分）
crossover(chromosome1, chromosome2)

#GPU交叉函数（选择一个点，交叉两条染色体）
gpu_crossover(chromosome1, chromosome2)

#修复交叉后存在Transformer层没有分配给GPU的问题
repair(matrix, j)

#变异函数，随机交换一条染色体两点的值
mutation(vector)

#块交叉，交叉两个矩阵，将两个矩阵按列切割成小块，等概率选择每一块形成新的矩阵
gpu_block_crossover(parent1, parent2)


#生成初始的Transformer分配情况
generate_matrix(n, k, j)

#生成初始任务序列
generate_initial_task_sequence(i, j)

#生成初始GPU序列
generate_machine_sequence(i, j, k):

# 初始化种群
generate_population(population_size, n, k, i, j)

# 精英选择：选择适应度分数最小的个体
select_elite(population, scores, elite_fraction=0.2)

# 交叉：根据crossover_rate1对向量1进行交叉，crossover_rate2对向量2进行交叉
genetic_crossover(population, crossover_rate1, crossover_rate2, i, j, k)

# 变异：对向量1和向量2进行变异，矩阵部分进行变异
mutate(population, mutation_rate, i, j, k)

# 更新种群：保留精英个体并将交叉和变异后的个体加入
update_population(elite_population, new_population, population_size)

3.最小GPU
给定可靠性下限 R0，看所需的最小GPU个数 （采用完整随机版的可靠性指标）


4.可靠性&利用率实验完整版
生成GPU数量k和指定代数下的系统可靠性&利用率

5.GPU性能实验
比较不同GPU性能下的系统可靠性

----------------------------------------------
修改：
GPU性能实验：
    - Genetic random 和 GPU random 合并，适应性评估中不需要gpu——random
    - 输入是Genetic.py的结果
可靠性利用率实验：
    - func: genetic_algorithm, adaptability_assessment, evaluate_population放到genetic中
    - ratio:取平均值和最小值
最小GPU：
    - func: genetic_algorithm, adaptability_assessment, evaluate_population放到genetic中
Genetic：
    - def genetic_alg(loc,scale):
        # GPU的性能参数也放进去
        f, g = Func(loc, scale)
        return ...
